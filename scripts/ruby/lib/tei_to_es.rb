require "nokogiri"
require_relative "helpers.rb"
require_relative "tei_to_es/fields.rb"
require_relative "tei_to_es/xpaths.rb"

#########################################
# NOTE:  DO NOT EDIT THIS FILE!!!!!!!!! #
#########################################
#   (unless you are a CDRH dev and then you may do so very cautiously)
#   this file provides defaults for ALL of the projects included
#   in the API and changing it could alter dozens of sites unexpectedly!
# PLEASE RUN LOADS OF TESTS AFTER A CHANGE BEFORE PUSHING TO PRODUCTION

# HOW DO I CHANGE XPATHS?
#   You may add or modify xpaths in each project's tei_to_es.rb file
#   located in the projects/<project>/scripts directory

# HOW DO I CHANGE FIELD CONTENT?
#   You may need to alter an xpath, but otherwise you may also
#   copy paste the field defined in tei_to_es/fields.rb and change
#   it as needed. If you are dealing with something particularly complex
#   you may need to consult with a CDRH dev for help

class TeiToEs

  attr_reader :json
  # variables
  # id, xml, parent_xml, options

  def initialize xml, options={}, parent_xml=nil, filename=nil
    @xml = xml
    @options = options
    @parent_xml = parent_xml
    @filename = filename
    @id = get_id
    @xpaths = xpaths_list
    create_json
  end

  # getter for @json response object
  def create_json
    @json = {}
    # if anything needs to be done before processing
    # do it here (ex: reading in annotations into memory)
    preprocessing
    assemble_json
    postprocessing
  end

  def get_id
    return @filename
  end

  def assemble_json
    # TODO might put these into methods themselves
    # so that a project could override only a clump of fields
    # rather than all?
    # Note: the above might only matter if ES can't handle nil
    # values being sent, because otherwise they could just override
    # the field behavior to be blank

    ###############
    # identifiers #
    ###############
    # cannot add this manually, have to do it via url
    # @json["_type"] = shortname
    @json["identifier"] = @id

    ##############
    # categories #
    ##############
    @json["category"] = category
    @json["subcategory"] = subcategory
    @json["data_type"] = "tei"
    @json["project"] = project
    @json["shortname"] = shortname
    # @json["subject"]

    #############
    # locations #
    #############

    # TODO check, because I'm not sure the schema
    # lists the urls that we actually want to use
    # earlywashingtondc.org vs cdrhmedia, etc
    # @json["uri"]
    # @json["uri_data"]
    # @json["uri_html"]
    # @json["image_location"]
    # @json["image_id"]

    ###############
    # description #
    ###############
    @json["title_sort"] = title_sort
    @json["title"] = title
    @json["description"] = description
    # @json["topics"]
    # @json["alternative"]

    ##################
    # other metadata #
    ##################
    @json["format"] = format
    @json["language"] = language
    # @json["relation"]
    # @json["type"]
    # @json["extent"]
    @json["medium"] = format

    #########
    # dates #
    #########
    @json["date_display"] = date_display
    @json["date"] = date
    @json["date_not_before"] = date
    @json["date_not_after"] = date false

    ####################
    # publishing stuff #
    ####################
    @json["rights_uri"] = rights_uri
    @json["publisher"] = publisher
    @json["rights"] = rights
    @json["source"] = source
    @json["rights_holder"] = rights_holder

    ##########
    # people #
    ##########
    @json["creator_sort"] = creator_sort
    @json["people"] = person_sort
    # container fields
    @json["person"] = person
    @json["contributor"] = contributors
    @json["creator"] = creator

    ###########
    # spatial #
    ###########
    # TODO not sure about the naming convention here?
    # TODO has place_name, coordinates, id, city, county, country,
    # region, state, street, postal_code
    # @json["coverage.spatial"]

    ##############
    # referenced #
    ##############
    @json["keywords"] = keywords
    @json["places"] = places
    @json["works"] = works

    #################
    # text searches #
    #################
    @json["annotations"] = annotations
    @json["text"] = text
    # @json["abstract"]
    more_fields = project_specific_fields
    @json.merge!(more_fields) if more_fields && !more_fields.empty?
    return @json
  end

  def override_xpaths
    {}
  end

  ###########
  # HELPERS #
  ###########

  # see helpers.rb's Common module for methods imported from common.xsl

  # get the value of one of the xpaths listed at the top
  # Note: if the xpath returns multiple values they will be squished together
  # TODO should we make it so that this can optionally look for more than one
  # result?

  # get_list
  #   can pass it a string xpath or array of xpaths
  # returns an array with the html value in xpath
  def get_list xpaths, keep_tags=false, xml=nil
    xpath_array = xpaths.class == Array ? xpaths : [xpaths]
    return get_xpaths xpath_array, keep_tags, xml
  end

  # get_text
  #   can pass it a string xpath or array of xpaths
  #   can optionally set a delimiter, otherwise ;
  # returns a STRING
  # if you want a multivalued result, please refer to get_list
  def get_text xpaths, keep_tags=false, xml=nil, delimiter=";"
    # ensure all xpaths are an array before beginning
    xpath_array = xpaths.class == Array ? xpaths : [xpaths]
    list = get_xpaths xpath_array, keep_tags, xml
    sorted = list.sort
    return sorted.join("#{delimiter} ")
  end

  # Note: Recommend that project team do NOT use this method directly
  #   please use get_list or get_text instead
  # keep_tags true will convert tags like <hi> to <em>
  #   use this wisely, as it causes performance issues
  # keep_tags false removes ALL tags from selected xpath
  def get_xpaths xpaths, keep_tags=false, xml=nil
    doc = xml || @xml
    list = []
    xpaths.each do |xpath|
      contents = doc.xpath(xpath)
      contents.each do |content|
        text = ""
        if keep_tags
          converted = Common.convert_tags(content)
          text = converted.inner_html
        else
          text = content.text
        end
        text = Common.squeeze(text)
        if text.length > 0
          list << text
        end
      end
    end
    return list.uniq
  end

  def preprocessing
    # copy this in your tei_to_es project file to customize
  end

  def postprocessing
    # copy this in your tei_to_es project file to customize
  end

end
